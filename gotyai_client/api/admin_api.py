# coding: utf-8

"""
    Gotyai API v3

    Gotyai API : the Spartan explainable AI   # noqa: E501

    OpenAPI spec version: 3.0.2
    Contact: contact@namsor.com
    Generated by: https://openapi-generator.tech
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from gotyai_client.api_client import ApiClient


class AdminApi(object):
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def abuse_name_patterns(self, **kwargs):  # noqa: E501
        """List blacklist name pattern.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.abuse_name_patterns(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.abuse_name_patterns_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.abuse_name_patterns_with_http_info(**kwargs)  # noqa: E501
            return data

    def abuse_name_patterns_with_http_info(self, **kwargs):  # noqa: E501
        """List blacklist name pattern.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.abuse_name_patterns_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method abuse_name_patterns" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api2/json/nameBlacklistPatterns', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_credits(self, api_key, usage_credits, user_message, **kwargs):  # noqa: E501
        """Add usage credits to an API Key.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_credits(api_key, usage_credits, user_message, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str api_key: (required)
        :param int usage_credits: (required)
        :param str user_message: (required)
        :return: APIPeriodUsageOut
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_credits_with_http_info(api_key, usage_credits, user_message, **kwargs)  # noqa: E501
        else:
            (data) = self.add_credits_with_http_info(api_key, usage_credits, user_message, **kwargs)  # noqa: E501
            return data

    def add_credits_with_http_info(self, api_key, usage_credits, user_message, **kwargs):  # noqa: E501
        """Add usage credits to an API Key.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_credits_with_http_info(api_key, usage_credits, user_message, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str api_key: (required)
        :param int usage_credits: (required)
        :param str user_message: (required)
        :return: APIPeriodUsageOut
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['api_key', 'usage_credits', 'user_message']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_credits" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'api_key' is set
        if ('api_key' not in local_var_params or
                local_var_params['api_key'] is None):
            raise ValueError("Missing the required parameter `api_key` when calling `add_credits`")  # noqa: E501
        # verify the required parameter 'usage_credits' is set
        if ('usage_credits' not in local_var_params or
                local_var_params['usage_credits'] is None):
            raise ValueError("Missing the required parameter `usage_credits` when calling `add_credits`")  # noqa: E501
        # verify the required parameter 'user_message' is set
        if ('user_message' not in local_var_params or
                local_var_params['user_message'] is None):
            raise ValueError("Missing the required parameter `user_message` when calling `add_credits`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'api_key' in local_var_params:
            path_params['apiKey'] = local_var_params['api_key']  # noqa: E501
        if 'usage_credits' in local_var_params:
            path_params['usageCredits'] = local_var_params['usage_credits']  # noqa: E501
        if 'user_message' in local_var_params:
            path_params['userMessage'] = local_var_params['user_message']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api2/json/addCredits/{apiKey}/{usageCredits}/{userMessage}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='APIPeriodUsageOut',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def api_key_info(self, **kwargs):  # noqa: E501
        """Read API Key info.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.api_key_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: APIKeyOut
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.api_key_info_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.api_key_info_with_http_info(**kwargs)  # noqa: E501
            return data

    def api_key_info_with_http_info(self, **kwargs):  # noqa: E501
        """Read API Key info.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.api_key_info_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: APIKeyOut
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_key_info" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api2/json/apiKeyInfo', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='APIKeyOut',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def api_usage(self, **kwargs):  # noqa: E501
        """Print current API usage.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.api_usage(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: APIPeriodUsageOut
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.api_usage_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.api_usage_with_http_info(**kwargs)  # noqa: E501
            return data

    def api_usage_with_http_info(self, **kwargs):  # noqa: E501
        """Print current API usage.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.api_usage_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: APIPeriodUsageOut
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_usage" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api2/json/apiUsage', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='APIPeriodUsageOut',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def api_usage_history(self, **kwargs):  # noqa: E501
        """Print historical API usage.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.api_usage_history(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: APIUsageHistoryOut
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.api_usage_history_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.api_usage_history_with_http_info(**kwargs)  # noqa: E501
            return data

    def api_usage_history_with_http_info(self, **kwargs):  # noqa: E501
        """Print historical API usage.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.api_usage_history_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: APIUsageHistoryOut
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_usage_history" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api2/json/apiUsageHistory', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='APIUsageHistoryOut',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def api_usage_history_aggregate(self, **kwargs):  # noqa: E501
        """Print historical API usage (in an aggregated view, by service, by day/hour/min).  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.api_usage_history_aggregate(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: APIUsageAggregatedOut
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.api_usage_history_aggregate_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.api_usage_history_aggregate_with_http_info(**kwargs)  # noqa: E501
            return data

    def api_usage_history_aggregate_with_http_info(self, **kwargs):  # noqa: E501
        """Print historical API usage (in an aggregated view, by service, by day/hour/min).  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.api_usage_history_aggregate_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: APIUsageAggregatedOut
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_usage_history_aggregate" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api2/json/apiUsageHistoryAggregate', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='APIUsageAggregatedOut',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def available_plans(self, **kwargs):  # noqa: E501
        """List all available plans in the default currency (usd).  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.available_plans(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: APIPlansOut
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.available_plans_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.available_plans_with_http_info(**kwargs)  # noqa: E501
            return data

    def available_plans_with_http_info(self, **kwargs):  # noqa: E501
        """List all available plans in the default currency (usd).  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.available_plans_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: APIPlansOut
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method available_plans" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api2/json/availablePlans', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='APIPlansOut',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def available_plans1(self, token, **kwargs):  # noqa: E501
        """List all available plans in the user's preferred currency.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.available_plans1(token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str token: (required)
        :return: APIPlansOut
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.available_plans1_with_http_info(token, **kwargs)  # noqa: E501
        else:
            (data) = self.available_plans1_with_http_info(token, **kwargs)  # noqa: E501
            return data

    def available_plans1_with_http_info(self, token, **kwargs):  # noqa: E501
        """List all available plans in the user's preferred currency.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.available_plans1_with_http_info(token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str token: (required)
        :return: APIPlansOut
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['token']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method available_plans1" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'token' is set
        if ('token' not in local_var_params or
                local_var_params['token'] is None):
            raise ValueError("Missing the required parameter `token` when calling `available_plans1`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'token' in local_var_params:
            path_params['token'] = local_var_params['token']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api2/json/availablePlans/{token}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='APIPlansOut',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def billing_currencies(self, **kwargs):  # noqa: E501
        """List possible currency options for billing (USD, EUR, GBP, ...)  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.billing_currencies(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: CurrenciesOut
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.billing_currencies_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.billing_currencies_with_http_info(**kwargs)  # noqa: E501
            return data

    def billing_currencies_with_http_info(self, **kwargs):  # noqa: E501
        """List possible currency options for billing (USD, EUR, GBP, ...)  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.billing_currencies_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: CurrenciesOut
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method billing_currencies" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api2/json/billingCurrencies', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CurrenciesOut',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def billing_history(self, token, **kwargs):  # noqa: E501
        """Read the history billing information (invoices paid via Stripe or manually).  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.billing_history(token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str token: (required)
        :return: BillingHistoryOut
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.billing_history_with_http_info(token, **kwargs)  # noqa: E501
        else:
            (data) = self.billing_history_with_http_info(token, **kwargs)  # noqa: E501
            return data

    def billing_history_with_http_info(self, token, **kwargs):  # noqa: E501
        """Read the history billing information (invoices paid via Stripe or manually).  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.billing_history_with_http_info(token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str token: (required)
        :return: BillingHistoryOut
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['token']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method billing_history" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'token' is set
        if ('token' not in local_var_params or
                local_var_params['token'] is None):
            raise ValueError("Missing the required parameter `token` when calling `billing_history`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'token' in local_var_params:
            path_params['token'] = local_var_params['token']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api2/json/billingHistory/{token}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BillingHistoryOut',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def billing_info(self, token, **kwargs):  # noqa: E501
        """Read the billing information (company name, address, phone, vat ID)  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.billing_info(token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str token: (required)
        :return: BillingInfoInOut
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.billing_info_with_http_info(token, **kwargs)  # noqa: E501
        else:
            (data) = self.billing_info_with_http_info(token, **kwargs)  # noqa: E501
            return data

    def billing_info_with_http_info(self, token, **kwargs):  # noqa: E501
        """Read the billing information (company name, address, phone, vat ID)  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.billing_info_with_http_info(token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str token: (required)
        :return: BillingInfoInOut
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['token']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method billing_info" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'token' is set
        if ('token' not in local_var_params or
                local_var_params['token'] is None):
            raise ValueError("Missing the required parameter `token` when calling `billing_info`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'token' in local_var_params:
            path_params['token'] = local_var_params['token']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api2/json/billingInfo/{token}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BillingInfoInOut',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def charge_new(self, stripe_token, stripe_email, **kwargs):  # noqa: E501
        """Create a Stripe Customer V2, based on a payment card token (from secure StripeJS) and email.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.charge_new(stripe_token, stripe_email, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str stripe_token: (required)
        :param str stripe_email: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.charge_new_with_http_info(stripe_token, stripe_email, **kwargs)  # noqa: E501
        else:
            (data) = self.charge_new_with_http_info(stripe_token, stripe_email, **kwargs)  # noqa: E501
            return data

    def charge_new_with_http_info(self, stripe_token, stripe_email, **kwargs):  # noqa: E501
        """Create a Stripe Customer V2, based on a payment card token (from secure StripeJS) and email.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.charge_new_with_http_info(stripe_token, stripe_email, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str stripe_token: (required)
        :param str stripe_email: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['stripe_token', 'stripe_email']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method charge_new" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'stripe_token' is set
        if ('stripe_token' not in local_var_params or
                local_var_params['stripe_token'] is None):
            raise ValueError("Missing the required parameter `stripe_token` when calling `charge_new`")  # noqa: E501
        # verify the required parameter 'stripe_email' is set
        if ('stripe_email' not in local_var_params or
                local_var_params['stripe_email'] is None):
            raise ValueError("Missing the required parameter `stripe_email` when calling `charge_new`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'stripe_token' in local_var_params:
            path_params['stripeToken'] = local_var_params['stripe_token']  # noqa: E501
        if 'stripe_email' in local_var_params:
            path_params['stripeEmail'] = local_var_params['stripe_email']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api2/json/chargeNew/{stripeToken}/{stripeEmail}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def corporate_key(self, api_key, corporate, **kwargs):  # noqa: E501
        """Setting an API Key to a corporate status.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.corporate_key(api_key, corporate, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str api_key: (required)
        :param bool corporate: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.corporate_key_with_http_info(api_key, corporate, **kwargs)  # noqa: E501
        else:
            (data) = self.corporate_key_with_http_info(api_key, corporate, **kwargs)  # noqa: E501
            return data

    def corporate_key_with_http_info(self, api_key, corporate, **kwargs):  # noqa: E501
        """Setting an API Key to a corporate status.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.corporate_key_with_http_info(api_key, corporate, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str api_key: (required)
        :param bool corporate: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['api_key', 'corporate']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method corporate_key" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'api_key' is set
        if ('api_key' not in local_var_params or
                local_var_params['api_key'] is None):
            raise ValueError("Missing the required parameter `api_key` when calling `corporate_key`")  # noqa: E501
        # verify the required parameter 'corporate' is set
        if ('corporate' not in local_var_params or
                local_var_params['corporate'] is None):
            raise ValueError("Missing the required parameter `corporate` when calling `corporate_key`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'api_key' in local_var_params:
            path_params['apiKey'] = local_var_params['api_key']  # noqa: E501
        if 'corporate' in local_var_params:
            path_params['corporate'] = local_var_params['corporate']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api2/json/corporateKey/{apiKey}/{corporate}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def count_spam_non_spam(self, duration_millis, **kwargs):  # noqa: E501
        """Get email spam statistics over custom duration.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.count_spam_non_spam(duration_millis, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int duration_millis: (required)
        :return: SpamStatsOut
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.count_spam_non_spam_with_http_info(duration_millis, **kwargs)  # noqa: E501
        else:
            (data) = self.count_spam_non_spam_with_http_info(duration_millis, **kwargs)  # noqa: E501
            return data

    def count_spam_non_spam_with_http_info(self, duration_millis, **kwargs):  # noqa: E501
        """Get email spam statistics over custom duration.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.count_spam_non_spam_with_http_info(duration_millis, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int duration_millis: (required)
        :return: SpamStatsOut
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['duration_millis']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method count_spam_non_spam" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'duration_millis' is set
        if ('duration_millis' not in local_var_params or
                local_var_params['duration_millis'] is None):
            raise ValueError("Missing the required parameter `duration_millis` when calling `count_spam_non_spam`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'duration_millis' in local_var_params:
            path_params['durationMillis'] = local_var_params['duration_millis']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api2/json/countSpamNonSpam/{durationMillis}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SpamStatsOut',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def count_spam_non_spam1(self, **kwargs):  # noqa: E501
        """Email spam statistics.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.count_spam_non_spam1(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: SpamStatsOut
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.count_spam_non_spam1_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.count_spam_non_spam1_with_http_info(**kwargs)  # noqa: E501
            return data

    def count_spam_non_spam1_with_http_info(self, **kwargs):  # noqa: E501
        """Email spam statistics.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.count_spam_non_spam1_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: SpamStatsOut
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method count_spam_non_spam1" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api2/json/countSpamNonSpam', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SpamStatsOut',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def debug_level(self, logger, level, **kwargs):  # noqa: E501
        """Update debug level for a classifier  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.debug_level(logger, level, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str logger: (required)
        :param str level: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.debug_level_with_http_info(logger, level, **kwargs)  # noqa: E501
        else:
            (data) = self.debug_level_with_http_info(logger, level, **kwargs)  # noqa: E501
            return data

    def debug_level_with_http_info(self, logger, level, **kwargs):  # noqa: E501
        """Update debug level for a classifier  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.debug_level_with_http_info(logger, level, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str logger: (required)
        :param str level: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['logger', 'level']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method debug_level" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'logger' is set
        if ('logger' not in local_var_params or
                local_var_params['logger'] is None):
            raise ValueError("Missing the required parameter `logger` when calling `debug_level`")  # noqa: E501
        # verify the required parameter 'level' is set
        if ('level' not in local_var_params or
                local_var_params['level'] is None):
            raise ValueError("Missing the required parameter `level` when calling `debug_level`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'logger' in local_var_params:
            path_params['logger'] = local_var_params['logger']  # noqa: E501
        if 'level' in local_var_params:
            path_params['level'] = local_var_params['level']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api2/json/debugLevel/{logger}/{level}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def disable(self, source, disabled, **kwargs):  # noqa: E501
        """Activate/deactivate an API Key.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.disable(source, disabled, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str source: The API Key to set as enabled/disabled. (required)
        :param bool disabled: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.disable_with_http_info(source, disabled, **kwargs)  # noqa: E501
        else:
            (data) = self.disable_with_http_info(source, disabled, **kwargs)  # noqa: E501
            return data

    def disable_with_http_info(self, source, disabled, **kwargs):  # noqa: E501
        """Activate/deactivate an API Key.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.disable_with_http_info(source, disabled, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str source: The API Key to set as enabled/disabled. (required)
        :param bool disabled: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['source', 'disabled']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method disable" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'source' is set
        if ('source' not in local_var_params or
                local_var_params['source'] is None):
            raise ValueError("Missing the required parameter `source` when calling `disable`")  # noqa: E501
        # verify the required parameter 'disabled' is set
        if ('disabled' not in local_var_params or
                local_var_params['disabled'] is None):
            raise ValueError("Missing the required parameter `disabled` when calling `disable`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'source' in local_var_params:
            path_params['source'] = local_var_params['source']  # noqa: E501
        if 'disabled' in local_var_params:
            path_params['disabled'] = local_var_params['disabled']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api2/json/disable/{source}/{disabled}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def email_blacklist_pattern_add(self, pattern, **kwargs):  # noqa: E501
        """Add blacklist email pattern.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.email_blacklist_pattern_add(pattern, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str pattern: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.email_blacklist_pattern_add_with_http_info(pattern, **kwargs)  # noqa: E501
        else:
            (data) = self.email_blacklist_pattern_add_with_http_info(pattern, **kwargs)  # noqa: E501
            return data

    def email_blacklist_pattern_add_with_http_info(self, pattern, **kwargs):  # noqa: E501
        """Add blacklist email pattern.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.email_blacklist_pattern_add_with_http_info(pattern, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str pattern: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['pattern']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method email_blacklist_pattern_add" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'pattern' is set
        if ('pattern' not in local_var_params or
                local_var_params['pattern'] is None):
            raise ValueError("Missing the required parameter `pattern` when calling `email_blacklist_pattern_add`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'pattern' in local_var_params:
            path_params['pattern'] = local_var_params['pattern']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api2/json/emailBlacklistPatternAdd/{pattern}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def email_blacklist_pattern_remove(self, pattern, **kwargs):  # noqa: E501
        """Remove blacklist email pattern.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.email_blacklist_pattern_remove(pattern, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str pattern: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.email_blacklist_pattern_remove_with_http_info(pattern, **kwargs)  # noqa: E501
        else:
            (data) = self.email_blacklist_pattern_remove_with_http_info(pattern, **kwargs)  # noqa: E501
            return data

    def email_blacklist_pattern_remove_with_http_info(self, pattern, **kwargs):  # noqa: E501
        """Remove blacklist email pattern.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.email_blacklist_pattern_remove_with_http_info(pattern, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str pattern: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['pattern']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method email_blacklist_pattern_remove" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'pattern' is set
        if ('pattern' not in local_var_params or
                local_var_params['pattern'] is None):
            raise ValueError("Missing the required parameter `pattern` when calling `email_blacklist_pattern_remove`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'pattern' in local_var_params:
            path_params['pattern'] = local_var_params['pattern']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api2/json/emailBlacklistPatternRemove/{pattern}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def email_blacklist_patterns(self, **kwargs):  # noqa: E501
        """List all blacklist email patterns.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.email_blacklist_patterns(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.email_blacklist_patterns_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.email_blacklist_patterns_with_http_info(**kwargs)  # noqa: E501
            return data

    def email_blacklist_patterns_with_http_info(self, **kwargs):  # noqa: E501
        """List all blacklist email patterns.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.email_blacklist_patterns_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method email_blacklist_patterns" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api2/json/emailBlacklistPatterns', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def explainability(self, source, explainable, **kwargs):  # noqa: E501
        """Activate/deactivate explainability for a source.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.explainability(source, explainable, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str source: (required)
        :param bool explainable: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.explainability_with_http_info(source, explainable, **kwargs)  # noqa: E501
        else:
            (data) = self.explainability_with_http_info(source, explainable, **kwargs)  # noqa: E501
            return data

    def explainability_with_http_info(self, source, explainable, **kwargs):  # noqa: E501
        """Activate/deactivate explainability for a source.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.explainability_with_http_info(source, explainable, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str source: (required)
        :param bool explainable: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['source', 'explainable']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method explainability" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'source' is set
        if ('source' not in local_var_params or
                local_var_params['source'] is None):
            raise ValueError("Missing the required parameter `source` when calling `explainability`")  # noqa: E501
        # verify the required parameter 'explainable' is set
        if ('explainable' not in local_var_params or
                local_var_params['explainable'] is None):
            raise ValueError("Missing the required parameter `explainable` when calling `explainability`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'source' in local_var_params:
            path_params['source'] = local_var_params['source']  # noqa: E501
        if 'explainable' in local_var_params:
            path_params['explainable'] = local_var_params['explainable']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api2/json/explainability/{source}/{explainable}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def flush(self, **kwargs):  # noqa: E501
        """Flush counters.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.flush(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.flush_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.flush_with_http_info(**kwargs)  # noqa: E501
            return data

    def flush_with_http_info(self, **kwargs):  # noqa: E501
        """Flush counters.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.flush_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method flush" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api2/json/flush', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def gotya_counter(self, **kwargs):  # noqa: E501
        """Get the overall API counter  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gotya_counter(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: GotyaCounterOut
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.gotya_counter_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.gotya_counter_with_http_info(**kwargs)  # noqa: E501
            return data

    def gotya_counter_with_http_info(self, **kwargs):  # noqa: E501
        """Get the overall API counter  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gotya_counter_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: GotyaCounterOut
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method gotya_counter" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api2/json/namsorCounter', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GotyaCounterOut',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def invalidate_cache(self, **kwargs):  # noqa: E501
        """Invalidate system caches.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.invalidate_cache(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.invalidate_cache_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.invalidate_cache_with_http_info(**kwargs)  # noqa: E501
            return data

    def invalidate_cache_with_http_info(self, **kwargs):  # noqa: E501
        """Invalidate system caches.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.invalidate_cache_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method invalidate_cache" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api2/json/invalidateCache', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def ip_addresses_blacklist_candidates(self, **kwargs):  # noqa: E501
        """List IP blacklist candidates.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.ip_addresses_blacklist_candidates(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.ip_addresses_blacklist_candidates_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.ip_addresses_blacklist_candidates_with_http_info(**kwargs)  # noqa: E501
            return data

    def ip_addresses_blacklist_candidates_with_http_info(self, **kwargs):  # noqa: E501
        """List IP blacklist candidates.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.ip_addresses_blacklist_candidates_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method ip_addresses_blacklist_candidates" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api2/json/ipAddressesBlacklistCandidates', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def name_blacklist_pattern_add(self, pattern, **kwargs):  # noqa: E501
        """Add blacklist name pattern.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.name_blacklist_pattern_add(pattern, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str pattern: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.name_blacklist_pattern_add_with_http_info(pattern, **kwargs)  # noqa: E501
        else:
            (data) = self.name_blacklist_pattern_add_with_http_info(pattern, **kwargs)  # noqa: E501
            return data

    def name_blacklist_pattern_add_with_http_info(self, pattern, **kwargs):  # noqa: E501
        """Add blacklist name pattern.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.name_blacklist_pattern_add_with_http_info(pattern, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str pattern: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['pattern']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method name_blacklist_pattern_add" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'pattern' is set
        if ('pattern' not in local_var_params or
                local_var_params['pattern'] is None):
            raise ValueError("Missing the required parameter `pattern` when calling `name_blacklist_pattern_add`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'pattern' in local_var_params:
            path_params['pattern'] = local_var_params['pattern']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api2/json/nameBlacklistPatternAdd/{pattern}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def name_blacklist_pattern_remove(self, pattern, **kwargs):  # noqa: E501
        """Remove blacklist name pattern.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.name_blacklist_pattern_remove(pattern, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str pattern: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.name_blacklist_pattern_remove_with_http_info(pattern, **kwargs)  # noqa: E501
        else:
            (data) = self.name_blacklist_pattern_remove_with_http_info(pattern, **kwargs)  # noqa: E501
            return data

    def name_blacklist_pattern_remove_with_http_info(self, pattern, **kwargs):  # noqa: E501
        """Remove blacklist name pattern.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.name_blacklist_pattern_remove_with_http_info(pattern, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str pattern: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['pattern']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method name_blacklist_pattern_remove" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'pattern' is set
        if ('pattern' not in local_var_params or
                local_var_params['pattern'] is None):
            raise ValueError("Missing the required parameter `pattern` when calling `name_blacklist_pattern_remove`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'pattern' in local_var_params:
            path_params['pattern'] = local_var_params['pattern']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api2/json/nameBlacklistPatternRemove/{pattern}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def payment_info(self, token, **kwargs):  # noqa: E501
        """Get the Stripe payment information associated with the current google auth session token.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.payment_info(token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str token: (required)
        :return: StripeCustomerOut
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.payment_info_with_http_info(token, **kwargs)  # noqa: E501
        else:
            (data) = self.payment_info_with_http_info(token, **kwargs)  # noqa: E501
            return data

    def payment_info_with_http_info(self, token, **kwargs):  # noqa: E501
        """Get the Stripe payment information associated with the current google auth session token.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.payment_info_with_http_info(token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str token: (required)
        :return: StripeCustomerOut
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['token']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method payment_info" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'token' is set
        if ('token' not in local_var_params or
                local_var_params['token'] is None):
            raise ValueError("Missing the required parameter `token` when calling `payment_info`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'token' in local_var_params:
            path_params['token'] = local_var_params['token']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api2/json/paymentInfo/{token}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='StripeCustomerOut',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def procure_key(self, token, recaptchav2, **kwargs):  # noqa: E501
        """Procure an API Key (sent via Email), based on an auth token and a recaptcha. Keep your API Key secret.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.procure_key(token, recaptchav2, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str token: (required)
        :param str recaptchav2: (required)
        :return: APIKeyOut
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.procure_key_with_http_info(token, recaptchav2, **kwargs)  # noqa: E501
        else:
            (data) = self.procure_key_with_http_info(token, recaptchav2, **kwargs)  # noqa: E501
            return data

    def procure_key_with_http_info(self, token, recaptchav2, **kwargs):  # noqa: E501
        """Procure an API Key (sent via Email), based on an auth token and a recaptcha. Keep your API Key secret.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.procure_key_with_http_info(token, recaptchav2, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str token: (required)
        :param str recaptchav2: (required)
        :return: APIKeyOut
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['token', 'recaptchav2']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method procure_key" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'token' is set
        if ('token' not in local_var_params or
                local_var_params['token'] is None):
            raise ValueError("Missing the required parameter `token` when calling `procure_key`")  # noqa: E501
        # verify the required parameter 'recaptchav2' is set
        if ('recaptchav2' not in local_var_params or
                local_var_params['recaptchav2'] is None):
            raise ValueError("Missing the required parameter `recaptchav2` when calling `procure_key`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'token' in local_var_params:
            path_params['token'] = local_var_params['token']  # noqa: E501
        if 'recaptchav2' in local_var_params:
            path_params['recaptchav2'] = local_var_params['recaptchav2']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api2/json/procureKey/{token}/{recaptchav2}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='APIKeyOut',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def procure_key1(self, token, **kwargs):  # noqa: E501
        """[compatibility] Retrieve the user's API Key, based on an auth token. Keep your API Key secret.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.procure_key1(token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str token: (required)
        :return: APIKeyOut
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.procure_key1_with_http_info(token, **kwargs)  # noqa: E501
        else:
            (data) = self.procure_key1_with_http_info(token, **kwargs)  # noqa: E501
            return data

    def procure_key1_with_http_info(self, token, **kwargs):  # noqa: E501
        """[compatibility] Retrieve the user's API Key, based on an auth token. Keep your API Key secret.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.procure_key1_with_http_info(token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str token: (required)
        :return: APIKeyOut
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['token']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method procure_key1" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'token' is set
        if ('token' not in local_var_params or
                local_var_params['token'] is None):
            raise ValueError("Missing the required parameter `token` when calling `procure_key1`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'token' in local_var_params:
            path_params['token'] = local_var_params['token']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api2/json/procureKey/{token}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='APIKeyOut',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def remove_payment(self, source_id, token, **kwargs):  # noqa: E501
        """Remove Stripe card associated with the current google auth session token.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.remove_payment(source_id, token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str source_id: (required)
        :param str token: (required)
        :return: StripeCustomerOut
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.remove_payment_with_http_info(source_id, token, **kwargs)  # noqa: E501
        else:
            (data) = self.remove_payment_with_http_info(source_id, token, **kwargs)  # noqa: E501
            return data

    def remove_payment_with_http_info(self, source_id, token, **kwargs):  # noqa: E501
        """Remove Stripe card associated with the current google auth session token.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.remove_payment_with_http_info(source_id, token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str source_id: (required)
        :param str token: (required)
        :return: StripeCustomerOut
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['source_id', 'token']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method remove_payment" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'source_id' is set
        if ('source_id' not in local_var_params or
                local_var_params['source_id'] is None):
            raise ValueError("Missing the required parameter `source_id` when calling `remove_payment`")  # noqa: E501
        # verify the required parameter 'token' is set
        if ('token' not in local_var_params or
                local_var_params['token'] is None):
            raise ValueError("Missing the required parameter `token` when calling `remove_payment`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'source_id' in local_var_params:
            path_params['sourceId'] = local_var_params['source_id']  # noqa: E501
        if 'token' in local_var_params:
            path_params['token'] = local_var_params['token']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api2/json/removePayment/{sourceId}/{token}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='StripeCustomerOut',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def remove_user_account(self, token, **kwargs):  # noqa: E501
        """Remove the user account.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.remove_user_account(token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str token: (required)
        :return: APIPlanSubscriptionOut
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.remove_user_account_with_http_info(token, **kwargs)  # noqa: E501
        else:
            (data) = self.remove_user_account_with_http_info(token, **kwargs)  # noqa: E501
            return data

    def remove_user_account_with_http_info(self, token, **kwargs):  # noqa: E501
        """Remove the user account.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.remove_user_account_with_http_info(token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str token: (required)
        :return: APIPlanSubscriptionOut
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['token']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method remove_user_account" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'token' is set
        if ('token' not in local_var_params or
                local_var_params['token'] is None):
            raise ValueError("Missing the required parameter `token` when calling `remove_user_account`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'token' in local_var_params:
            path_params['token'] = local_var_params['token']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api2/json/removeUserAccount/{token}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='APIPlanSubscriptionOut',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def remove_user_account_on_behalf(self, api_key, **kwargs):  # noqa: E501
        """Remove (on behalf) a user account.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.remove_user_account_on_behalf(api_key, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str api_key: (required)
        :return: APIPlanSubscriptionOut
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.remove_user_account_on_behalf_with_http_info(api_key, **kwargs)  # noqa: E501
        else:
            (data) = self.remove_user_account_on_behalf_with_http_info(api_key, **kwargs)  # noqa: E501
            return data

    def remove_user_account_on_behalf_with_http_info(self, api_key, **kwargs):  # noqa: E501
        """Remove (on behalf) a user account.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.remove_user_account_on_behalf_with_http_info(api_key, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str api_key: (required)
        :return: APIPlanSubscriptionOut
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['api_key']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method remove_user_account_on_behalf" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'api_key' is set
        if ('api_key' not in local_var_params or
                local_var_params['api_key'] is None):
            raise ValueError("Missing the required parameter `api_key` when calling `remove_user_account_on_behalf`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'api_key' in local_var_params:
            path_params['apiKey'] = local_var_params['api_key']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api2/json/removeUserAccountOnBehalf/{apiKey}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='APIPlanSubscriptionOut',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def resend_key(self, token, recaptchav2, **kwargs):  # noqa: E501
        """Resend an API Key (sent via Email), based on an auth token and a recaptcha as well as verification link. Keep your API Key secret.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.resend_key(token, recaptchav2, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str token: (required)
        :param str recaptchav2: (required)
        :return: APIKeyOut
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.resend_key_with_http_info(token, recaptchav2, **kwargs)  # noqa: E501
        else:
            (data) = self.resend_key_with_http_info(token, recaptchav2, **kwargs)  # noqa: E501
            return data

    def resend_key_with_http_info(self, token, recaptchav2, **kwargs):  # noqa: E501
        """Resend an API Key (sent via Email), based on an auth token and a recaptcha as well as verification link. Keep your API Key secret.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.resend_key_with_http_info(token, recaptchav2, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str token: (required)
        :param str recaptchav2: (required)
        :return: APIKeyOut
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['token', 'recaptchav2']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method resend_key" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'token' is set
        if ('token' not in local_var_params or
                local_var_params['token'] is None):
            raise ValueError("Missing the required parameter `token` when calling `resend_key`")  # noqa: E501
        # verify the required parameter 'recaptchav2' is set
        if ('recaptchav2' not in local_var_params or
                local_var_params['recaptchav2'] is None):
            raise ValueError("Missing the required parameter `recaptchav2` when calling `resend_key`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'token' in local_var_params:
            path_params['token'] = local_var_params['token']  # noqa: E501
        if 'recaptchav2' in local_var_params:
            path_params['recaptchav2'] = local_var_params['recaptchav2']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api2/json/resendKey/{token}/{recaptchav2}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='APIKeyOut',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def retrieve_key(self, token, **kwargs):  # noqa: E501
        """Retrieve the user's API Key, based on an auth token. Keep your API Key secret.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.retrieve_key(token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str token: (required)
        :return: APIKeyOut
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.retrieve_key_with_http_info(token, **kwargs)  # noqa: E501
        else:
            (data) = self.retrieve_key_with_http_info(token, **kwargs)  # noqa: E501
            return data

    def retrieve_key_with_http_info(self, token, **kwargs):  # noqa: E501
        """Retrieve the user's API Key, based on an auth token. Keep your API Key secret.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.retrieve_key_with_http_info(token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str token: (required)
        :return: APIKeyOut
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['token']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method retrieve_key" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'token' is set
        if ('token' not in local_var_params or
                local_var_params['token'] is None):
            raise ValueError("Missing the required parameter `token` when calling `retrieve_key`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'token' in local_var_params:
            path_params['token'] = local_var_params['token']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api2/json/retrieveKey/{token}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='APIKeyOut',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def shutdown(self, **kwargs):  # noqa: E501
        """Stop learning and shutdown system.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.shutdown(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.shutdown_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.shutdown_with_http_info(**kwargs)  # noqa: E501
            return data

    def shutdown_with_http_info(self, **kwargs):  # noqa: E501
        """Stop learning and shutdown system.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.shutdown_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method shutdown" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api2/json/shutdown', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def signups(self, ip_address, **kwargs):  # noqa: E501
        """List userID signups by IP address.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.signups(ip_address, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str ip_address: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.signups_with_http_info(ip_address, **kwargs)  # noqa: E501
        else:
            (data) = self.signups_with_http_info(ip_address, **kwargs)  # noqa: E501
            return data

    def signups_with_http_info(self, ip_address, **kwargs):  # noqa: E501
        """List userID signups by IP address.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.signups_with_http_info(ip_address, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str ip_address: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['ip_address']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method signups" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'ip_address' is set
        if ('ip_address' not in local_var_params or
                local_var_params['ip_address'] is None):
            raise ValueError("Missing the required parameter `ip_address` when calling `signups`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'ip_address' in local_var_params:
            path_params['ipAddress'] = local_var_params['ip_address']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api2/json/signups/{ipAddress}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def software_version(self, **kwargs):  # noqa: E501
        """Get the current software version  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.software_version(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: SoftwareVersionOut
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.software_version_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.software_version_with_http_info(**kwargs)  # noqa: E501
            return data

    def software_version_with_http_info(self, **kwargs):  # noqa: E501
        """Get the current software version  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.software_version_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: SoftwareVersionOut
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method software_version" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api2/json/softwareVersion', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SoftwareVersionOut',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def spamsurge(self, block_disposable_emails, **kwargs):  # noqa: E501
        """Activate/deactivate blocking of disposable emails in case of spam surge.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.spamsurge(block_disposable_emails, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param bool block_disposable_emails: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.spamsurge_with_http_info(block_disposable_emails, **kwargs)  # noqa: E501
        else:
            (data) = self.spamsurge_with_http_info(block_disposable_emails, **kwargs)  # noqa: E501
            return data

    def spamsurge_with_http_info(self, block_disposable_emails, **kwargs):  # noqa: E501
        """Activate/deactivate blocking of disposable emails in case of spam surge.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.spamsurge_with_http_info(block_disposable_emails, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param bool block_disposable_emails: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['block_disposable_emails']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method spamsurge" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'block_disposable_emails' is set
        if ('block_disposable_emails' not in local_var_params or
                local_var_params['block_disposable_emails'] is None):
            raise ValueError("Missing the required parameter `block_disposable_emails` when calling `spamsurge`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'block_disposable_emails' in local_var_params:
            path_params['blockDisposableEmails'] = local_var_params['block_disposable_emails']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api2/json/spamsurge/{blockDisposableEmails}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def stats(self, **kwargs):  # noqa: E501
        """Print basic system statistics.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.stats(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: SystemMetricsOut
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.stats_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.stats_with_http_info(**kwargs)  # noqa: E501
            return data

    def stats_with_http_info(self, **kwargs):  # noqa: E501
        """Print basic system statistics.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.stats_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: SystemMetricsOut
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stats" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api2/json/stats', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SystemMetricsOut',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def subscribe_plan(self, plan_name, token, **kwargs):  # noqa: E501
        """Subscribe to a give API plan, using the user's preferred or default currency.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.subscribe_plan(plan_name, token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str plan_name: (required)
        :param str token: (required)
        :return: APIPlanSubscriptionOut
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.subscribe_plan_with_http_info(plan_name, token, **kwargs)  # noqa: E501
        else:
            (data) = self.subscribe_plan_with_http_info(plan_name, token, **kwargs)  # noqa: E501
            return data

    def subscribe_plan_with_http_info(self, plan_name, token, **kwargs):  # noqa: E501
        """Subscribe to a give API plan, using the user's preferred or default currency.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.subscribe_plan_with_http_info(plan_name, token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str plan_name: (required)
        :param str token: (required)
        :return: APIPlanSubscriptionOut
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['plan_name', 'token']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method subscribe_plan" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'plan_name' is set
        if ('plan_name' not in local_var_params or
                local_var_params['plan_name'] is None):
            raise ValueError("Missing the required parameter `plan_name` when calling `subscribe_plan`")  # noqa: E501
        # verify the required parameter 'token' is set
        if ('token' not in local_var_params or
                local_var_params['token'] is None):
            raise ValueError("Missing the required parameter `token` when calling `subscribe_plan`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'plan_name' in local_var_params:
            path_params['planName'] = local_var_params['plan_name']  # noqa: E501
        if 'token' in local_var_params:
            path_params['token'] = local_var_params['token']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api2/json/subscribePlan/{planName}/{token}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='APIPlanSubscriptionOut',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def subscribe_plan_on_behalf(self, plan_name, api_key, **kwargs):  # noqa: E501
        """Subscribe to a give API plan, using the user's preferred or default currency (admin only).  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.subscribe_plan_on_behalf(plan_name, api_key, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str plan_name: (required)
        :param str api_key: (required)
        :return: APIPlanSubscriptionOut
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.subscribe_plan_on_behalf_with_http_info(plan_name, api_key, **kwargs)  # noqa: E501
        else:
            (data) = self.subscribe_plan_on_behalf_with_http_info(plan_name, api_key, **kwargs)  # noqa: E501
            return data

    def subscribe_plan_on_behalf_with_http_info(self, plan_name, api_key, **kwargs):  # noqa: E501
        """Subscribe to a give API plan, using the user's preferred or default currency (admin only).  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.subscribe_plan_on_behalf_with_http_info(plan_name, api_key, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str plan_name: (required)
        :param str api_key: (required)
        :return: APIPlanSubscriptionOut
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['plan_name', 'api_key']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method subscribe_plan_on_behalf" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'plan_name' is set
        if ('plan_name' not in local_var_params or
                local_var_params['plan_name'] is None):
            raise ValueError("Missing the required parameter `plan_name` when calling `subscribe_plan_on_behalf`")  # noqa: E501
        # verify the required parameter 'api_key' is set
        if ('api_key' not in local_var_params or
                local_var_params['api_key'] is None):
            raise ValueError("Missing the required parameter `api_key` when calling `subscribe_plan_on_behalf`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'plan_name' in local_var_params:
            path_params['planName'] = local_var_params['plan_name']  # noqa: E501
        if 'api_key' in local_var_params:
            path_params['apiKey'] = local_var_params['api_key']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api2/json/subscribePlanOnBehalf/{planName}/{apiKey}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='APIPlanSubscriptionOut',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def switch_default_api_key_active(self, default_blocked, **kwargs):  # noqa: E501
        """Switch defaullt API Key as blocked (need email verif) or active.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.switch_default_api_key_active(default_blocked, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param bool default_blocked: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.switch_default_api_key_active_with_http_info(default_blocked, **kwargs)  # noqa: E501
        else:
            (data) = self.switch_default_api_key_active_with_http_info(default_blocked, **kwargs)  # noqa: E501
            return data

    def switch_default_api_key_active_with_http_info(self, default_blocked, **kwargs):  # noqa: E501
        """Switch defaullt API Key as blocked (need email verif) or active.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.switch_default_api_key_active_with_http_info(default_blocked, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param bool default_blocked: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['default_blocked']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method switch_default_api_key_active" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'default_blocked' is set
        if ('default_blocked' not in local_var_params or
                local_var_params['default_blocked'] is None):
            raise ValueError("Missing the required parameter `default_blocked` when calling `switch_default_api_key_active`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'default_blocked' in local_var_params:
            path_params['defaultBlocked'] = local_var_params['default_blocked']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api2/json/switchDefaultAPIKeyActive/{defaultBlocked}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_billing_info(self, token, **kwargs):  # noqa: E501
        """Sets or update the billing information (company name, address, phone, vat ID)  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_billing_info(token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str token: (required)
        :param BillingInfoInOut billing_info_in_out:
        :return: BillingInfoInOut
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_billing_info_with_http_info(token, **kwargs)  # noqa: E501
        else:
            (data) = self.update_billing_info_with_http_info(token, **kwargs)  # noqa: E501
            return data

    def update_billing_info_with_http_info(self, token, **kwargs):  # noqa: E501
        """Sets or update the billing information (company name, address, phone, vat ID)  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_billing_info_with_http_info(token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str token: (required)
        :param BillingInfoInOut billing_info_in_out:
        :return: BillingInfoInOut
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['token', 'billing_info_in_out']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_billing_info" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'token' is set
        if ('token' not in local_var_params or
                local_var_params['token'] is None):
            raise ValueError("Missing the required parameter `token` when calling `update_billing_info`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'token' in local_var_params:
            path_params['token'] = local_var_params['token']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'billing_info_in_out' in local_var_params:
            body_params = local_var_params['billing_info_in_out']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json;charset=UTF-8'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api2/json/updateBillingInfo/{token}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BillingInfoInOut',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_limit(self, usage_limit, hard_or_soft, token, **kwargs):  # noqa: E501
        """Modifies the hard/soft limit on the API plan's overages (default is 0$ soft limit).  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_limit(usage_limit, hard_or_soft, token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int usage_limit: (required)
        :param bool hard_or_soft: (required)
        :param str token: (required)
        :return: APIPeriodUsageOut
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_limit_with_http_info(usage_limit, hard_or_soft, token, **kwargs)  # noqa: E501
        else:
            (data) = self.update_limit_with_http_info(usage_limit, hard_or_soft, token, **kwargs)  # noqa: E501
            return data

    def update_limit_with_http_info(self, usage_limit, hard_or_soft, token, **kwargs):  # noqa: E501
        """Modifies the hard/soft limit on the API plan's overages (default is 0$ soft limit).  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_limit_with_http_info(usage_limit, hard_or_soft, token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int usage_limit: (required)
        :param bool hard_or_soft: (required)
        :param str token: (required)
        :return: APIPeriodUsageOut
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['usage_limit', 'hard_or_soft', 'token']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_limit" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'usage_limit' is set
        if ('usage_limit' not in local_var_params or
                local_var_params['usage_limit'] is None):
            raise ValueError("Missing the required parameter `usage_limit` when calling `update_limit`")  # noqa: E501
        # verify the required parameter 'hard_or_soft' is set
        if ('hard_or_soft' not in local_var_params or
                local_var_params['hard_or_soft'] is None):
            raise ValueError("Missing the required parameter `hard_or_soft` when calling `update_limit`")  # noqa: E501
        # verify the required parameter 'token' is set
        if ('token' not in local_var_params or
                local_var_params['token'] is None):
            raise ValueError("Missing the required parameter `token` when calling `update_limit`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'usage_limit' in local_var_params:
            path_params['usageLimit'] = local_var_params['usage_limit']  # noqa: E501
        if 'hard_or_soft' in local_var_params:
            path_params['hardOrSoft'] = local_var_params['hard_or_soft']  # noqa: E501
        if 'token' in local_var_params:
            path_params['token'] = local_var_params['token']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api2/json/updateLimit/{usageLimit}/{hardOrSoft}/{token}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='APIPeriodUsageOut',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_payment_default(self, defaut_source_id, token, **kwargs):  # noqa: E501
        """Update the default Stripe card associated with the current google auth session token.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_payment_default(defaut_source_id, token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str defaut_source_id: (required)
        :param str token: (required)
        :return: StripeCustomerOut
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_payment_default_with_http_info(defaut_source_id, token, **kwargs)  # noqa: E501
        else:
            (data) = self.update_payment_default_with_http_info(defaut_source_id, token, **kwargs)  # noqa: E501
            return data

    def update_payment_default_with_http_info(self, defaut_source_id, token, **kwargs):  # noqa: E501
        """Update the default Stripe card associated with the current google auth session token.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_payment_default_with_http_info(defaut_source_id, token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str defaut_source_id: (required)
        :param str token: (required)
        :return: StripeCustomerOut
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['defaut_source_id', 'token']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_payment_default" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'defaut_source_id' is set
        if ('defaut_source_id' not in local_var_params or
                local_var_params['defaut_source_id'] is None):
            raise ValueError("Missing the required parameter `defaut_source_id` when calling `update_payment_default`")  # noqa: E501
        # verify the required parameter 'token' is set
        if ('token' not in local_var_params or
                local_var_params['token'] is None):
            raise ValueError("Missing the required parameter `token` when calling `update_payment_default`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'defaut_source_id' in local_var_params:
            path_params['defautSourceId'] = local_var_params['defaut_source_id']  # noqa: E501
        if 'token' in local_var_params:
            path_params['token'] = local_var_params['token']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api2/json/updatePaymentDefault/{defautSourceId}/{token}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='StripeCustomerOut',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_user_info(self, email, display_name, token, **kwargs):  # noqa: E501
        """Sets or update the user email and name information  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_user_info(email, display_name, token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str email: (required)
        :param str display_name: (required)
        :param str token: (required)
        :return: UserInfoOut
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_user_info_with_http_info(email, display_name, token, **kwargs)  # noqa: E501
        else:
            (data) = self.update_user_info_with_http_info(email, display_name, token, **kwargs)  # noqa: E501
            return data

    def update_user_info_with_http_info(self, email, display_name, token, **kwargs):  # noqa: E501
        """Sets or update the user email and name information  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_user_info_with_http_info(email, display_name, token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str email: (required)
        :param str display_name: (required)
        :param str token: (required)
        :return: UserInfoOut
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['email', 'display_name', 'token']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_user_info" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'email' is set
        if ('email' not in local_var_params or
                local_var_params['email'] is None):
            raise ValueError("Missing the required parameter `email` when calling `update_user_info`")  # noqa: E501
        # verify the required parameter 'display_name' is set
        if ('display_name' not in local_var_params or
                local_var_params['display_name'] is None):
            raise ValueError("Missing the required parameter `display_name` when calling `update_user_info`")  # noqa: E501
        # verify the required parameter 'token' is set
        if ('token' not in local_var_params or
                local_var_params['token'] is None):
            raise ValueError("Missing the required parameter `token` when calling `update_user_info`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'email' in local_var_params:
            path_params['email'] = local_var_params['email']  # noqa: E501
        if 'display_name' in local_var_params:
            path_params['displayName'] = local_var_params['display_name']  # noqa: E501
        if 'token' in local_var_params:
            path_params['token'] = local_var_params['token']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api2/json/updateUserInfo/{email}/{displayName}/{token}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='UserInfoOut',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def user_info(self, token, **kwargs):  # noqa: E501
        """Get the user profile associated with the current google auth session token.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.user_info(token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str token: (required)
        :return: UserInfoOut
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.user_info_with_http_info(token, **kwargs)  # noqa: E501
        else:
            (data) = self.user_info_with_http_info(token, **kwargs)  # noqa: E501
            return data

    def user_info_with_http_info(self, token, **kwargs):  # noqa: E501
        """Get the user profile associated with the current google auth session token.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.user_info_with_http_info(token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str token: (required)
        :return: UserInfoOut
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['token']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method user_info" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'token' is set
        if ('token' not in local_var_params or
                local_var_params['token'] is None):
            raise ValueError("Missing the required parameter `token` when calling `user_info`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'token' in local_var_params:
            path_params['token'] = local_var_params['token']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api2/json/userInfo/{token}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='UserInfoOut',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def verify_email(self, email_token, **kwargs):  # noqa: E501
        """Verifies an email, based on token sent to that email  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.verify_email(email_token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str email_token: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.verify_email_with_http_info(email_token, **kwargs)  # noqa: E501
        else:
            (data) = self.verify_email_with_http_info(email_token, **kwargs)  # noqa: E501
            return data

    def verify_email_with_http_info(self, email_token, **kwargs):  # noqa: E501
        """Verifies an email, based on token sent to that email  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.verify_email_with_http_info(email_token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str email_token: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['email_token']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method verify_email" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'email_token' is set
        if ('email_token' not in local_var_params or
                local_var_params['email_token'] is None):
            raise ValueError("Missing the required parameter `email_token` when calling `verify_email`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'email_token' in local_var_params:
            path_params['emailToken'] = local_var_params['email_token']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api2/json/verifyEmail/{emailToken}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def verify_remove_email(self, email_token, **kwargs):  # noqa: E501
        """Verifies an email, based on token sent to that email  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.verify_remove_email(email_token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str email_token: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.verify_remove_email_with_http_info(email_token, **kwargs)  # noqa: E501
        else:
            (data) = self.verify_remove_email_with_http_info(email_token, **kwargs)  # noqa: E501
            return data

    def verify_remove_email_with_http_info(self, email_token, **kwargs):  # noqa: E501
        """Verifies an email, based on token sent to that email  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.verify_remove_email_with_http_info(email_token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str email_token: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['email_token']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method verify_remove_email" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'email_token' is set
        if ('email_token' not in local_var_params or
                local_var_params['email_token'] is None):
            raise ValueError("Missing the required parameter `email_token` when calling `verify_remove_email`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'email_token' in local_var_params:
            path_params['emailToken'] = local_var_params['email_token']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api2/json/verifyRemoveEmail/{emailToken}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)
